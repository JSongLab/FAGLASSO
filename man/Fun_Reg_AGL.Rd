% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FAGLasso_base_functions.R
\name{Fun_Reg_AGL}
\alias{Fun_Reg_AGL}
\title{Funtional Adaptive Group Lasso function.}
\usage{
Fun_Reg_AGL(
  y,
  design,
  Ps,
  basis_num,
  fpca_basis_num,
  basis_list = NULL,
  weights,
  fpca = FALSE,
  lambda_1 = NULL,
  lambda_2 = NULL,
  n_lamb_1 = 20,
  n_lamb_2 = 10,
  cv = 5,
  cv_average = FALSE,
  active_dim = 1e-06,
  add_iter = NULL,
  init = NULL,
  max_iter = 1000,
  standardnorm = FALSE
)
}
\arguments{
\item{y}{vector of response variable.}

\item{design}{design matrix \code{[ [x^1_1:n]^T ... [x^p_1:n]^T ] in R^{ n x (m_1 + ... m_j) }}.
Note that there is no gram matrix, so, we assume that orthonormal basis system is used such as fourier or eigenfunctions.}

\item{Ps}{A matris of roughness penalties, structured as diag(P_1, ... , P_p), where each P_i represents a specific penalty matrix.
For instance, P_i could be 'bsplinepen(..., Lfdobj=2)'.}

\item{basis_num}{A vector of the number of basis functions used; (m_1, ...., m_p).}

\item{fpca_basis_num}{A vector indicating the number of eigenfunctions of FPCA for the basis system. It is allowed to differ from 'basis_num'.}

\item{basis_list}{A list where \code{'basis_list[[j]]'} contains the information for the basis used to represent the j-th explanatory function.
Therefore, \code{'basis_list[[j]]'} should be populated with basis creation functions such as 'create.bsplinebasis(...)' or 'create.fourierbasis(...)'.
If 'fpca' is set to 'TRUE', this argument is required.}

\item{weights}{weights of group lasso penalties. If you want to conduct non-adaptive group lasso, then set all weights to one.}

\item{fpca}{It has a Boolean value. If se to 'True', a basis system based on FPCA is used. Otherwise, it is assumed that the Fourier basis system will be employed.}

\item{lambda_1}{It defines the search range for group lasso penalty, specified as a vector in the format \code{c(min, max)}. If set to \code{NULL}, it defaults to \code{c(1e-5, 1e-1)}.}

\item{lambda_2}{It defines the search range for each roughness penalty. It is represented as a matrix with p rows and 2 columns, where each row corresponds to a specific roughness penalty.
Specifically, \code{lambda_2[j,]} contains the range with the form of c(min, max) for the j-th roughness penalty.}

\item{n_lamb_1}{The number of grid for the range specified in lambda_1.}

\item{n_lamb_2}{The common number of grid for the range specified in lambda_2.}

\item{cv}{It specifies the number of folds for K-fold cross-validation used to identify optival values for 'lambda_1' and 'lambda_2s'.
Here, 'optimal' refers to minimizing the test MSE in each fold.}

\item{cv_average}{It has a Boolean value (True/False). If set to true, the final result is the average of the estimated functions across each fold.
Otherwise, the weights determined through cross-validation are applied to the entire trainning dataset to produce the final result.}

\item{active_dim}{This is identical argument of 'matpower'.}

\item{add_iter}{It specifies the number of additional iterations for optimizing 'lambda_2s'. By default, it is set to 'NULL', indicating no additional iterations.
Otherwise, it accepts a positive integer. If 'add_iter=k', then fixing the group lasso penalty value('lambda_1'), k additional optimization processes are carried out for 'lambda_2s'.}

\item{init}{Initial value of optimization, if null, optimization starts at (0, ..... , 0).}

\item{max_iter}{the number of max iteration.}

\item{standardnorm}{If set to 'TRUE', the standard L2 norm is employed instead of our gamma norm. Note that it is just for the simulation study.}
}
\value{
A list with the following components:
\itemize{
\item \code{beta_hat}: the coordinates of estimated functions. It is vector with its length being (m_1 + ... m_p).
\item \code{lambda_1}: lambda_1 selected by cross validation.
\item \code{lambda_2}: lambda_2s selected by cross validation.
\item \code{cov_mat}: list object with \code{cov_mat[[j]]}=The coordinate representation of j-th covariance operators,
whose basis system is identical to the design specifed in input argument such as 'fourier', 'bspline'.
This output can be used to calculate \code{w_{1j}}s.
}
}
\description{
Funtional Adaptive Group Lasso function.
}
